package play.groovysupport

import javassist.CtClass
import javassist.Modifier
import javassist.bytecode.Opcode
import play.classloading.enhancers.Enhancer
import play.classloading.ApplicationClasses.ApplicationClass
import java.lang.reflect.Field

/**
 * Do some crazy byte code modifications on generated groovy code
 * to allow hotswap of recompiled groovy sources.
 * <p/>
 * We have to remove static field generated by groovy groovyCompiler
 * that changes name with each recompile (contains compilation timestamp in it's name)
 * to allow hotswap of groovy byte code in JVM. Other way we get error that class
 * schema is changed.
 * <p/>
 * This code also removes initialization of this variable in static code
 * so app does not break when it tries to load modified class.
 *
 * @author Marek Piechut <marek.piechut@gmail.com>
 */
class ClearGroovyStampsEnhancer extends Enhancer {

    @Override
    void enhanceThisClass(ApplicationClass appClass) {
        if (appClass.javaFile.name.endsWith('.groovy')) {
            def cc = makeClass(appClass)
            if (!cc.packageName?.startsWith('play.')) {
                appClass.enhancedByteCode = clearGroovyStamps(cc)

                cc.defrost()
            }
        }
    }

    /**
     * Do some crazy byte code modifications on generated groovy code
     * to allow hotswap of recompiled groovy sources.
     * <p/>
     * We have to remove static field generated by groovy groovyCompiler
     * that changes name with each recompile (contains compilation timestamp in it's name)
     * to allow hotswap of groovy byte code in JVM. Other way we get error that class
     * schama is changed.
     * <p/>
     * This code also removes initialization of this variable in static code
     * so app does not break when it tries to load modified class.
     *
     * @return modified byte code
     */
    def clearGroovyStamps(CtClass cc) {
        def oldFieldName
        for (field in cc.declaredFields) {
            //This generated groovy field
            if (field.name.startsWith("__timeStamp__")) {
                oldFieldName = field.name
                //Let's rename it to something constant and make private
                field.setModifiers(Modifier.PRIVATE | Modifier.STATIC)
                field.setName("__timeStamp__")
                break;
            }
        }

        if (oldFieldName) {
            //Ok field was found and renamed, let's clean the initializer

            def initializer = cc.classInitializer;
            def mi = initializer.getMethodInfo();
            def ca = mi.getCodeAttribute();

            def ci = ca.iterator()
            //Let's check all byte code operations in static initializer
            while (ci.hasNext()) {
                def index = ci.next()
                int op = ci.byteAt(index)
                //PUTSTATIC is a byte code instruction to assign value from stack to static variable
                if (op == Opcode.PUTSTATIC) {
                    //Address of target variable is calculated like this
                    def targetFieldAddr = (ci.byteAt(index + 1) << 8) + ci.byteAt(index + 2)
                    def fieldrefName = mi.getConstPool().getFieldrefName(targetFieldAddr)
                    if (fieldrefName == oldFieldName) {
                        //Ok, so it's an assignment to renamed variable
                        //Let's change assignment to pop from stack (POP2 -> pop long/double value)
                        //We have to remove it or stack won't be valid
                        ci.writeByte((byte) Opcode.POP2, index);
                        //PUTSTATIC takes 2 arguments so we have to clear them out or
                        //they will be used as byte code instructions and probably invalidate class
                        ci.writeByte((byte) Opcode.NOP, index + 1);
                        ci.writeByte((byte) Opcode.NOP, index + 2);
                    }
                }

            }
        }

        return cc.toBytecode()
    }
}
